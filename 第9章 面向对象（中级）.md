---
title: 第九章 面向对象（中级）
date: 2023-10-10 15:00:00
tags: 韩顺平Java学习
---

# 第9章 面向对象（中级）

## IDEA编译器

### IDEA快捷键

1. 删除当前行`ctrl+d`
2. 复制当前行`ctrl+alt+向下光标`
3. 补全代码`alt+/`
4. 添加注释或者取消注释`ctrl+/`
5. 导入该行需要的类`alt+enter`
6. 快速格式化代码`ctrl+alt+L`
7. 快速运行程序`alt+R`
8. 生成构造方法`alt+insert`
9. 查看一个类的层级关系`ctrl+H`
10. 定位类的方法，查看某方法的源码`ctrl+B`
11. 自动分配变量名`.var`

### IDEA模板

`settings->Editor->Live Templates`里面都有

### IDEA小技巧

点左下角的Structure可以看到一个对象的方法

在IDEA中动态传参数：Edit Configurations -> Program arguments

## 包

作用

1. 区分相同名字的类
2. 当类很多时，可以很好地管理类
3. 控制访问范围

基本语法

```java
package com.xxx.xxx......
    //package打包，后接包名
```

### 包的本质

创建不同的文件夹来保存类文件

### 包的命名

只能包含数字、字母、下划线、小圆点。但是不能用数字开头，不能是关键字或保留字

一般是小写字母+小圆点，一般是`com.公司名.项目名.业务名`，例如`com.sina.crm.user`

### 常用的包

`java.lang.*`默认引入

`java.util.*`系统提供的工具包

`java.net.*`网络包，网络开发

`java.awt.*`java界面开发，GUI

### 注意事项

package声明当前类所在的包，需要放在类的最上面，一个类最多只有一句package

import指令要求在package下面，可以有多句且没有顺序要求

<img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220129223654194.png" alt="image-20220129223654194" style="zoom:40%;" />

## 访问修饰符

| 访问级别 | 访问修饰符 | 同类 | 同包 | 子类 | 不同包 |
| -------- | ---------- | ---- | ---- | ---- | ------ |
| 公开     | public     | ✓    | ✓    | ✓    | ✓      |
| 受保护   | protected  | ✓    | ✓    | ✓    |        |
| 默认     | 没有修饰符 | ✓    | ✓    |      |        |
| 私有     | private    | ✓    |      |      |        |

## 封装（encapsulation）

将抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法]，才能对数据进行操作

### 封装的好处

1. 隐藏实现的细节
2. 对数据进行验证，保证安全合理

### 封装的实现步骤（三部曲）

1. 将属性进行私有化private【外部不能直接修改属性】
2. 提供一个公共的(public)set方法，用于对属性判断并赋值

```java
public void setXxx(类型 参数名){
    //加入数据验证的业务逻辑
    属性 = 参数名；
}
```
 可以使用快捷键处理

3. 提供一个公共的(public)get方法，用于获取属性的值

```java
public XX getXxx(){//权限判断，Xxx某个属性
    return xx;
}
```

### 封装与构造器

将set方法写在构造器中，仍然可以起到防护的机制

```java
public Person(String name, int age){
    //this.age = age;
    //this.name = name; 这样不好
    setName(name);//这样更好
    setAge(age);
} 
```

## 继承（extends）

用于解决代码复用问题。多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类（超类），在父类中定义这些相同的属性和方法，所有的子类不需要再重新定义这些属性和方法，只需要通过extends来声明继承父类即可。

**继承设计的基本思想**：父类构造器完成父类属性初始化，子类构造器完成子类属性初始化

<img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220130165109518.png" alt="image-20220130165109518" style="zoom:45%;" />

### 继承的基本语法

```java
class 子类 extends 父类{
    
}
```

1. 子类自动拥有父类定义的属性和方法
2. 父类又叫超类、基类
3. 子类又叫派生类

### 继承的细节

1. 子类继承了所有的属性和方法，**非私有的属性和方法可以直接访问在子类直接访问**，**但是私有属性和方法不能在子类直接访问**，要通过公共的方法来访问

2. 子类必须调用父类的构造器，完成父类的初始化。子类里面默认调用了父类的无参构造器`super()`。

3. 当创造子类对象时，不管使用子类的哪个构造器，**默认情况下总会去调用父类的无参构造器**，如果父类没有提供无参构造器，则必须在子类的构造器中用super去**指定使用父类的哪个构造器完成对父类的初始化工作**，否则编译不会通过。

4. 如果希望指定去调用父类的某个构造器，则显示的调用一下。

   如果不是默认的无参构造器，那么需要显示调用父类的该构造器`super(对应实参)`

5. `super`在使用时，必须放在构造器第一行

6. `super()`和`this()`都只能放在构造器第一行，因此这两个方法不能共存于同一个构造器，二者不能同时存在。

7. java所有类都是Object类的子类，Object是所有类的基类（`ctrl+H`可以看到类的继承层次）

8. 父类构造器的调用不限于直接父类，将一直追溯直到Object类（顶级父类）。调用了就会从祖宗到子类一路下来，全部调。

9. 子类最多只能继承一个父类（直接继承），即java是单继承机制。若想让A继承B和C，则可以让B继承C后，再让A继承B。

10. 不能滥用继承，子类和父类必须满足**is-a**的逻辑关系

### 继承的本质分析（重要）

当子类对象创建好后，建立查找的关系

示例代码：

```java
public class ExtendsTheory {
    public static void main(String[] args) {
        Son son = new Son();
    }
}

class GrandPa {//爷类
    String name = "大头爷爷";
    String hobby = "旅游";
}

class Father extends GrandPa {//父类
    String name = "大头爸爸";
    int age = 39;
}

class Son extends Father {//子类
    String name = "大头儿子";
}
```

内存布局

<img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220130214915549.png" alt="image-20220130214915549" style="zoom:40%;" />

1. 首先看子类是否有该属性
2. 如果子类有这个属性，且可以访问，则返回信息
3. 如果子类没有这个属性，就看父类有没有这个属性（如果父类有该属性。且可以访问，就返回信息。。。。）
4. 如果父类没有，就按照（3）的规则，继续找上级父类，直到Object。。。

private的属性也存在于堆中，但是不能直接访问，使用方法间接访问即可。如果上级有public的，直接访问的话其会访问第一个public。

### 例题

```java
public class ExtendsTheory {
    public static void main(String[] args) {
        B b = new B();
    }
}

class A{
    A(){
        System.out.println("a的无参构造器");
    }

    A(String name){
        System.out.println("a的有参构造器");
    }
}

class B extends A{
    B(){
        //由于下面有this，此处原本隐藏的super()被撤销
        this("abs");
        System.out.println("b的无参构造器");
    }

    B(String name){
        //此处隐藏了一个super()
        System.out.println("b的有参构造器");
    }
}
```

输出的是

```bash
a的无参构造器
b的有参构造器
b的无参构造器
```

首先从进入B无参构造器的this中，**注意此处由于B的无参构造器有`this`，因此此处的默认的`super()`也消失了,所以他直接进入了`this`而没有处理`super()`**。然后进入B的有参构造器，此处有一个默认的`super()`，所以进入A的无参构造器，而后输出B的有参构造器中的内容。最后回到B的无参构造器，输出其内容。记住，**所有构造器在没有this存在的时候都有一个默认的super()**

## super关键字

super代表父类的引用，用于访问父类的属性、方法、构造器

### 基本语法

1. 访问父类的属性，但不能访问父类的private属性

   `super.属性名`

2. 访问父类的方法，但不能访问父类的private方法

   `super.方法名(参数列表)`

3. 访问父类的构造器（这点前面用过）：

   `super(参数列表);`只能用在构造器的第一句，只能出现一句。

### super给编程带来的便利/细节

1. 调用父类构造器的好处（分工明确）
2. 当子类有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。若没有重名，使用super、this、直接访问都是一样的结果。直接访问的顺序：先找本类，如果有，则调用，如果没有，则找父类，直到Object。super顺序：直接查找父类，跳过本类，其他逻辑一致。

3. super的访问不限于直接父类，如果爷爷类和本类都有同名的成员，也可以使用super去访问爷爷类的成员；如多个基类都有同名成员，使用super方法遵循就近原则。

### super和this的比较

| No.  | 区别点     | this                                   | super                                  |
| ---- | ---------- | -------------------------------------- | -------------------------------------- |
| 1    | 访问成员   | 访问本类的成员，如果本类没有就去找父类 | 直接访问父类中的成员，跳过本类         |
| 2    | 调用构造器 | 调用本类构造器，必须放在构造器首行     | 调用父类构造器，必须放在子类构造器首行 |
| 3    | 特殊       | 表示当前对象                           | 子类中访问父类对象                     |

## 方法重写/覆盖（override）

子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们说这个子类的方法覆盖了父类的方法

### 注意事项和使用细节

1. 子类的方法的参数、方法名称，要和父类方法的参数、方法名称完全一致
2. 子类的返回类型和父类方法返回类型一样，或者是父类返回类型的子类。例如父类返回Object，子类返回String
3. 子类方法不能缩小父类方法的权限

## 多态（polymorphic）

问题：代码复用性不高，不利于代码维护

多态：方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承基础之上的。

Java有两种引用类型，分别是编译时类型和运行时类型。编译型类型在变量声明时决定，运行时类型取决于变量具体指向的类型，如果两种类型不一致，就会出现多态。

规则：对象调用编译时类型的属性和运行时类型的方法。

### 具体体现

1. 方法的多态：重载和重写体现多态

2. 对象的多态（**核心、困难、重点**）

   - 一个对象的编译类型和运行类型可以不一致

     ```java
     Animal animal = new Dog();//【animal编译类型是Animal，运行类型是Dog】
     animal = new Cat();//【animal的运行类型变成了Cat，编译类型仍然是Animal】
     ```

   - 编译类型在定义对象时就确定了，**不能改变**。（编译器可以认为是编译器看到的类型）（直接把编译类型看成指针类型就好了）

     ```java
     //编译类型Animal确定了，不能改变
     ```

   - 运行类型是**可以变化**的。（运行类型则是运行时真正起作用的类型）。可以通过`getClass()`来查看运行类型。

     ```java
     //运行类型Dog可以变成Cat
     ```

   - **编译类型**看定义时 `=` 号的左边，**运行类型**看 `=` 号的右边。

   ``` java
   //使用多态可以统一管理主人喂食的问题
   //animal编译类型是Animal，可以指向（接收）Animal子类的对象
   //food编译类型是Food，可以指向（接收）Food子类的对象
   public void feed(Animal animal,Food food){
       System.out.println("主人给" + name + "给" + animal.getName() + "吃" + food.getName);
   }
   ```

### 多态注意事项和细节讨论

1. 前提：两个对象（类）存在继承关系

2. 多态的向上转型
   - 本质：父类的引用指向了子类的对象（继承图里面父类在上面，子类在下面，所以叫向上转型）
   
   - 语法：`父类类型 引用名 = new 子类类型();`
   
     ```java
     Animal animal = new Cat();
     ```
   
   - 特点：
     - **编译类型**看左边，**运行类型**看右边。
     
     - 可以调用父类中的所有成员（遵循访问权限（也就是public，private这种））
     
     - 不能调用子类中的特有成员（因为在编译阶段，能调用哪些成员是由编译类型决定）
     
     - 最终运行效果看子类的具体表现
     
       ```java
       animal.eat()//先去cat中找eat，再去animal找。。。与方法的调用规则一致
       ```
   
3. 多态的向下转型
   - 语法：`子类类型 应用名 = （子类类型）父类引用;`
   
     ```java
     Cat cat = (Cat) animal;//cat的编译类型是Cat，运行类型是Cat
     ```
   
   - 只能强转父类的**引用**，不能强转父类的**对象**（小明这个人就是这个人，他可以改名，但是他不能不是他自己）
   
   - 要求父类的引用必须指向的是当前目标类型的对象
   
   - 当向下转型后，可以调用子类类型中所有的成员

   <img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230913210624732.png" alt="向上转型和向下转型的示意图" style="zoom:80%;" />
   
   需要注意的是：图中指向方向是从 **对象** 指向其对应的 **引用**
   
   ```java
   Object o = string; //此处为一个向上转型。解释为对一个string对象赋予Object，父类的引用指向了子类的对象。
   String s = (String) o;//此处为一个向下转型
   ```
   
4. 属性没有重写之说，属性的值看**编译类型**，编译器通过编译类型去寻找属性（成员变量）。而方法则是通过**运行类型**，然后根据相应的**继承顺序**来访问（前面写过这个顺序）。

5. `instanceOf` 比较操作符，用于判断对象的**运行类型**是否为XX类型或XX类型的子类型

```java
public class Main {
    public static void main(String[] args) {
        Sub s = new Sub();
        System.out.println(s.count);//20
        s.display();//20
        Base b = s;
        System.out.println(b == s);//true
        System.out.println(b.count);//这里要注意了，属性的值看编译类型，此处b的编译类型是Base，因此count=10
        b.display();//与上面不同，方法从子类开始找起，看的是运行类型，所以其取20
    }
}
```

```java
public class Base {
    int count = 10;
    public void display(){
        System.out.println(this.count);
    }
}

class Sub extends Base{
    int count = 20;
    public void display(){
        System.out.println(this.count);
    }
}
```

[多态示例代码](https://github.com/Bixlku/JavaStudyCode/tree/main/PolyMorphism)

### Java的动态绑定机制（非常非常重要）

1. 当调用对象方法的时候，该方法会和该对象的内存地址（**运行类型**）绑定
2. 当调用对象属性时，**没有动态绑定机制**，哪里声明，哪里使用

```java
public class DynamicBinding {
    public static void main(String[] args) {
        A a = new B();
        System.out.println(a.sum());//40->30
        System.out.println(a.sum1());//30->20
    }
}
```

```java
public class A {
    public int i = 10;

    public int sum() {
        return getI() + 10;
    }
    public int getI() {
        return i + 10;
    }
    public int sum1() {
        return i + 10;
    }
}

class B extends A {
    public int i = 20;

    // public int sum() {
    //     return i + 20;
    // }
    public int getI() {
        return i;
    }
    // public int sum1() {
    //     return i + 10;
    // }
}
```

[Java动态绑定机制示例代码](https://github.com/Bixlku/JavaStudyCode/tree/main/DynamicBinding)

### 多态应用

1. 多态数组

   数组的定义类型为父类类型，里面保存的实际元素类型为子类类型

2. 多态参数

   方法定义的形参类型为父类类型，实参类型允许为子类类型

## Object类详解

### equals和==

==：

1. 如果判断基本类型，则判断的是值是否相等
2. 如果判断引用类型，则判断地址是否相等，即判定是不是同一个对象
3. 如果不是同一个类型，且其无继承关系，会报错

equals：

只能判断引用类型，默认判断的是地址是否相相等，子类中往往重写该方法，用于判断内容是否相等

### hashCode

1. 提高具有哈希结构的容器的效率
2. 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的
3. 两个引用，如果指向的是不同对象，则哈希值是不一样的
4. 哈希值主要是根据地址号来的，不能将哈希值等价于地址
5. 后面在集合中，hashCode如果需要的话，也会重写

### toString

1. 默认返回：全类名+@+哈希值的十六进制，子类往往重写toString方法，用于返回对象的属性信息

2. 重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式

3. 输出一个对象时，toString方法会被默认调用

```java
System.out.println(a)会默认调用a.toString()
```

### finalize

1. 当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法。finalize本身是空的，可以重写该方法来实现自己的业务逻辑。
2. 什么时候被回收：当某个对象没有被任何引用时，则JVM就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象。在销毁该对象前，会先调用finalize方法
3. 垃圾回收机制的调用，是由系统来决定（即有自己的GC算法），也可以通过`System.gc()`主动触发垃圾回收机制

## 零钱通

[零钱通示例代码](https://github.com/Bixlku/JavaStudyCode/tree/main/SmallChange)

## 房屋出租

[房屋出租示例代码](https://github.com/Bixlku/JavaStudyCode/tree/main/HouseRent)
