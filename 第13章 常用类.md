---
title: 第13章 常用类
date: 2023-10-10 15:08:00
tags: 韩顺平Java学习
---

# 第13章 常用类

## 包装类 Wrapper

1. 针对八种基本数据类型相应的引用类型——包装类

2. 有了类的特点，就可以调用类中的方法

| 基本数据类型 | 包装类    |
| ------------ | --------- |
| boolean      | Boolean   |
| char         | Character |
| byte         | Byte      |
| short        | Short     |
| int          | Integer   |
| long         | Long      |
| float        | Float     |
| double       | Double    |

<img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/image-20230915142938465.png" alt="继承关系" style="zoom: 67%;" />

<img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/image-20230915143030998.png" alt="继承关系" style="zoom:80%;" />

<img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/image-20230915143048622.png" alt="继承关系" style="zoom:80%;" />

### 包装类和基本数据的转换

1. **装箱**：基本类型->包装类型；**拆箱**：包装类型->基本类型

2. jdk5（包括jdk5）以后都是自动装箱和自动拆箱

3. 自动装箱底层调用的是valueOf()方法，例如：Integer.valueOf()

```java
//手动装箱
int n1 = 100;
Integer integer = new Integer(n1);//手动装箱方法1
Integer integer = Integer.valueOf(n1);//手动装箱方法2
//手动拆箱
int i = integer.intValue();

//jdk5后，自动装箱和自动拆箱
int n2 = 200;
//自动装箱
Integer integer2 = n2;//底层是用的是Integer.valueOf(n2)
//自动拆箱
int n3 = integer2;//底层是用的是intValue()方法
```

### 包装类型和String类型的相互转换

```java
//包装类(Integer)->String
Integer i = 12;
//方式1
String str = i +"";
//方式2
String str1 = i.toString();
//方式3
String str2 = String.valueOf(i);

//String->包装类(Integer)
String str4 = "114514";
//方式1
Integer integer1 = Integer.parseInt(str4);//自动装箱
//方式2
Integer integer2 = new Integer(str4);//构造器。已经是Deprecated了，官方不建议
```

### 常用的方法

```java
Integer.MIN_VALUE;//返回最小值
Integer.MAX_VALUE;//返回最大值
Character.isDigit('a');//判断是不是数字
Character.isLetter('a');//判断是不是字母
Character.isUpperCase('a');//判断是不是大写
Character.isLowerCase('a');//判断是不是小写
Character.isWhitespace('a');//判断是不是空格
Character.toUpperCase('a');//转换成大写
Character.toLowerCase('a');//转换成小写
```

### Integer类的范围提示

```java
Integer n1 = 127;
Integer n2 = 127;
System.out.println(n1==n2);//这里输出true

Integer n3 = 128;
Integer n4 = 128;
System.out.println(n3==n4);//这里输出false
//因为Integer类的源码中，-127-127范围内返回的都是int，而范围外返回的都是new的对象
//只要==的两边有基本数据类型，那么对比的一定是值
```

## 🚩String

1. String类用于存储字符串，即一组字符序列

2. 字符串的字符使用Unicode字符编码，一个字符（不区分字母还是汉字）占两个字节

3. String类常用构造器

   ```java
   String s1 = new String;
   String s2 = new String(String original);
   String s3 = new String(char[] a);
   String s4 = new String(char[] a,int startIndex,int count);
   ```

4. String是final类，**不能**被其他的类**继承**

5. String有属性 private final char value[];用于存放字符串内容

6. 一定要注意：value是一个final类型，不可以修改（final不可修改指的是**不能指向新的地址**，但是**单个字符**的内容是可以变化的）

   ```java
   String name = "jack";
   final char[] value = {'a','b','c'};
   char[] v2 = {'t','o','m'};
   value[0] = 'H';//此处不报错
   value = v2;//此处报错
   ```

7. Serializable：实现了串行化，说明可以在网络中传输

   Comparable：实现了Comparable接口，说明String对象可以比较大小

   ![image-20230916101911861](https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/image-20230916101911861.png)

### 创建String对象的两种方式

1. 直接赋值 `String s = "hspedu"`。只要不是new出来的，就都会直接放在方法区里面，不会进堆

   ![image-20230916112013487](https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/image-20230916112013487.png)

2. 调用构造器 `String s2 = new String("hsp");`

   ![image-20230916112030189](https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/image-20230916112030189.png)

![image-20230917143702258](https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/image-20230917143702258.png)

```java
s.equals(s2);//equals方法比较的是值，所以这里是True
s == s2;//这里是False，因为s2指向堆，而s指向常量池
//.intern()方法返回的是常量池的地址
//It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.
s == s2.intern();//此处返回的是True
s == s.intern();//此处返回的是False
```

#### 关于`.intern()`方法的小练习：

```java
public static void main(String[] args) {
	String str1 = "Runoob";
	String str2 = new String("Runoob");
	String str3 = str2.intern();
    System.out.println(str1 == str2);  // false
	System.out.println(str1 == str3);  // true
}
```

其文字解释为：

以上实例中，str1 是直接赋值的字符串常量，它会被自动添加到字符串池中。str2 是通 过new String() 创建的新字符串对象，它不会自动添加到字符串池中。然后，通过调用 intern() 方法，将 str2 添加到字符串池中，并返回字符串池中的引用，保存在 str3 中。

注意，== 运算符用于比较引用是否相等。在上面的示例中，str1 == str3 返回 true，这是因为它们都引用字符串池中的同一个对象。

其图像解释为：

<img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/e717021464726c7b4b32792e037889e.png" alt="e717021464726c7b4b32792e037889e" style="zoom:80%;" />

```java
public class WrapperType02 {
    public static void main(String[] args) {
        Person p1 = new Person();
        p1.name = "test";
        Person p2 = new Person();
        p2.name = "test";

        System.out.println(p1.name.equals(p2.name));//True
        System.out.println(p1.name == p2.name);//True
        System.out.println(p1.name == "test");//True

        String s1 = new String("test2");
        String s2 = new String("test2");
        System.out.println(s1==s2);//False
        //搞清楚内存分布图
    }
}
```



### 字符串特性

1. 编译器会自动进行优化，判断创建的常量池对象，例如`String a = "hello" + "world"`会直接优化成`String a = "helloworld"`。所以只会创建一个对象。

```java
String a = "hello";
String b = "abc";
String c = a + b;//c=a+b这里是有讲究的
//1. 先创建一个StringBuilder sb = StringBuilder()
//2. 执行 sb.append("hello");
//3. sb.append("abc")
//4. 相当于String c = sb.toString()
//最后其实是c指向堆中的对象
String d = "helloabc"
d == c//返回False，因为c指向的是堆中的对象，而d直接指向池中的对象
String e = "hello" + "abc"
e == d//返回True
```

#### 练习题：画出下图的内存布局图

```java
public class Test1 {
    String str = new String("hsp");
    char[] ch = {'j','a','v','a'};
    public static void main(String[] args) {
        Test1 ex = new Test1();  
        ex.change(ex.str,ex.ch);
        System.out.println(ex.str+" and ");
        System.out.println(ex.ch);
    }
    
    public void change(String str,char[] ch){
        str = "java";
        ch[0] = 'h';
    }
}
```

<img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/image-20230918114742030.png" alt="内存布局图" style="zoom:80%;" />

## String类的常用方法

String类是保存字符串常量的。每次更新都需要重新开辟空间，效率较低。因此开发者设计了StringBuilder和StringBuffer来增强String的功能
* `equals` 区分大小写判断内容是否相等
* `equalsIgnoreCase` 忽略大小写判断内容是否相等
* `length` 获取字符的个数
* `indexOf` 获取字符串中第一次出现的索引，索引从0开始，如果找不到，就返回-1
* `lastIndexOf` 获取字符在字符串中最后一次出现的索引，索引从0开始，如果找不到，就返回-1
* `substring` 截取指定范围内的子串
* `trim` 去掉前后空格
* `charAt` 获取某索引处的字符，注意没有`str[index]`这种形式 
* `toUpperCase` 变成大写字符
* `toLowerCase` 变成小写字符
* `concat` 拼接字符串
* `replace` 替换字符串中的字符
* `split` 分割字符串
* `compareTo` 比较两个字符串的大小（不懂的话建议去看源码）

  1.  返回值为0时，说面两个字符串相等
  2.  若前者大，则返回正数；若后者大，则返回负数
* `toCharArray` 转换成字符数组
* `format` 格式字符串（类c写法）

## StringBuffer类
![20230919141502](https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/vscode/20230919141502.png)

1. StringBuffer的直接父类是AbstractBuilder
2. StringBuffer实现了Serialzable，即StringBuffer的对象可以串行化
3. 在父类中 AbstractStringBuilder有属性byte[] value，不是final。该value数组存放字符内容，引出存放在堆中。
   
   从jdk9开始char[]被改为了byte[]，因为AbstractStringBuilder大部分情况下存放的都是拉丁字母，使用Byte的话一个拉丁字母只需要占据1个字节的容量，所以现在使用非拉丁字母时，使用UTF-16编码，需要使用isLatin1进行区分
4. StringBuilder类是一个final类，不能被继承
5. StringBuilder的字符内容存放在byte[] value中，所以更改后不是每次都要变换地址（如果空间不够还是会改变地址的）

## String VS StringBuffer
1. String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低//`private final char value[]`
2. StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次都更新地址，所以效率比较高。//`char[] value` //这个放在堆中


## StringBuffer构造器
1. `StringBuffer()` 构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符。
2. `StringBuffer(CharSequence seq)` 构造一个字符串缓冲区，它包含与指定的 CharSequence 相同的字符。
3. `StringBuffer(int capacity)` 构造一个不带字符，但具有指定初始容量的字符串缓冲区。即对char［］大小进行指定
4. `StringBuffer(String str)` 构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容。其cahr[]大小为str.length()+16

## StringBuffer转换
String -> StringBuffer

1. 使用构造器

    ```
    StringBuffer sb = new StringBuffer(str);
    ```

2. 使用append()方法
    
    ```
    StringBuffer sb = new StringBuffer(); 
    sb = sb.append(str);
    ```
StringBuffer -> String

1. 使用StringBuffer提供的toString方法
    ```
   String s = sb.toString()
   ```

2. 使用构造器

    ```
    String s1 = new String(sb);
    ```

## StringBuffer的常用方法

1. `append` 增
2. `delete(start,end)` 删
3. `replace(start,end,string)` 改。将start-end区间的内容替换为string
4. `indexOf` 查
5. `insert(index,str)` 在index处插入str，原来索引为index的元素自动后移
6. `length` 获取长度

## StringBuilder类
1. 可变字符序列，使用与StringBuffer兼容的API ，但是不保证同步（不是线程安全的）。用作StringBuffer的简易替换，用在字符串缓冲区被单线程使用的时候。如果可能建议使用该类，因为其比StringBuffer要快
2. StringBuilder的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据

## String、StingBuffer、StringBuilder比较
1. StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样
2. String：不可变字符序列，效率低，但是复用率高。如果需要对String进行大量修改，就不要使用String，应当选择StringBuffer和StringBuilder
3. StringBuffer：可变字符序列、效率较高（增删）、线程安全
4. StringBuilder：可变字符序列、效率最高、线程不安全

## Math类
常用的**静态方法**
1. `abs()` 求绝对值
2. `pow()` 求幂
3. `ceil()` 向上取整
4. `floor()` 向上取整
5. `round()` 四舍五入
6. `sqrt()` 求开方
7. `random()` 求随机数，返回一个[0,1)的随机小数
8. `max()` 求两个数的最大值
9. `min()` 求两个数的最小值

## Arrays类
1. `Arrays.toString()` 显示数组
2. `Arrays.sort()` 排序 

    * 因为数组是引用类型，所以通过sort排序后，会直接影响到实参arr。

    * sort是重载的，也可以通过传入一个接口 Comparator 实现定制排序
    
    * 定制排序：
    
    ```java
    Arrays.sort(arr,new Comparator(){
        @Override
        public int compare(Object o1, Object o2){
            相关程序代码
            return int1-int2;
        }
    })
    ```
    
    传入两个参数：

    （1） 排序的数组`arr`
    
    （2）实现了Comparator接口的匿名内部类，要求其实现compare方法。其底层调用了**二叉排序**，compare方法返回的int值的正负会直接影响排序是从小到大还是从大到小。如果i1-i2则为从小到大，反之则为从大到小

3. `Arrays.binarySearch()` 通过二分搜索法进行查找，要求数组有序

4. `copyOf` 数组元素的复制 
    
    `Integer[] newArr = Arrays.copyOf(arr,arr.length)` 从arr数组中，拷贝arr.length个元素到newArr数组中。如果拷贝的长度大于arr.length，就在新数组后面加null；如果拷贝的长度小于0，就抛出异常NegativeArraySizeException。

5. `Arrays.fill(arr,element)` 数组填充。将所有元素替换为element

6. `Arrays.equals(arr1,arr2)` 比较两个数组的内容是否完全一致

7. `Arrays.asList()` 将一组值，转换为list。

## System类

1. `exit` 退出当前程序
2. `arraycopy()` 复制数组元素，适合底层调用。一般选用`Arrays.copyOf()`，其底层调用的就是`arraycopy()`
3. `currentTimeMillens()` 返回当前时间距离1970-1-1的毫秒数
4. `gc` 运行垃圾回收机制 System.gc()

## BigInteger和BigDecimal类

应用场景：

1. BigInteger适合保存比较大的整型

2. BigDecimal适合保存进度更高的浮点型（小数）


对BigInteger或BigDecimal进行加减乘除时，不能直接写运算符号，而应该调用对应的方法

在调用devide方法时，需要指定精度，即BigDecimal.ROUND_CEILING。其精度与分子相同
