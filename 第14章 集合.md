---
title: 第14章 集合
date: 2023-10-10 15:09:00
tags: 韩顺平Java学习
---

# 第14章 集合

## 集合的理解和好处

数组：
1. 长度开始时必须指定，而且一旦指定，不能修改
2. 保存的必须为同一类型的元素
3. 使用数组进行增加/删除元素 比较麻烦

集合：
1. 可以动态保存任意多个对象，使用方便
2. 提供一系列方便的操作对象的方法：add、remove、set、get
3. 使用集合添加、删除元素比较间接

## 集合框架体系

必背

### Collection：单列集合
![20230924170531](https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/vscode/20230924170531.png)

### Map：双列集合
![20230924170449](https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/vscode/20230924170449.png)

## Collection接口和常用方法

### Collection接口实现类的特点

```java
public interface Collection<E> extends Iterable<E>
```

1. Collection实现子类可以存放多个元素，每个元素可以是Object
2. 有些Collection实现类可以存放重复元素，有些不能；有些是有序的（List），有些是无序的（Set）
3. Collection接口**没有直接**的子类，是通过它的子接口Set和List来实现的

### 使用ArrayList演示常用方法

1. `add`： 添加单个元素（有自动装箱功能）
2. `remove`： 删除指定元素
    `list.remove(int index)`删除序列为index的元素
    `list.remove(Object o)`删除指定元素的第一个出现。 如果不包含该元素，则不会更改。
3. `contains`：查找元素是否存在
4. `size`：获取元素个数
5. `isEmpty`：判断是否为空
6. `clear`：清空
7. `addAll`：添加多个元素
8. `containsAll`：查找多个元素是否都存在
9. `removeAll`：删除多个元素

### Collection接口遍历元素方式
1. 使用Iterator（迭代器）
    
    * Iterator对象称为迭代器，主要用于遍历Collection集合中的元素
    * 所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator()接口的对象，即可以返回一个迭代器
    * 使用Iterator.next()之前，必须先用hasNext()，否则可能会抛出NoSuchElementException
    * 如果希望再次遍历，需要重置迭代器

2. 增强for循环
    
    增强for循环，可以代替iterator迭代器，特点：增强for就是简化版的iterator，本质一样。只能用于遍历集合或数组。

    基本语法
    ```java
    for(元素类型 元素名:集合名或数组名)
        访问元素
    ```

    实际上增强for循环底层就是调用了iterator的next()。可以理解为简化版本的迭代器遍历。

    快捷方式：`I`

## List接口

1. List集合类中元素有序（即添加顺序和去除顺序一致）、且可重复
2. List集合中的每个元素都有其对应的顺序索引，即支持索引
3. List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素
4. 实现List接口的实现类有很多，常见的有ArrayList、LinkedList和Vector

### 常用方法

1. `void add(int index, Object ele)` 在index位置插入ele元素

2. `boolean addAll(int index, Collection eles)` 从index位置开始将eles中的所有元素都添加进来

3. `Object get(int index)` 获取指定index位置的元素

4. `int indexOf(Object obj)` 返回obj在集合中首次出现的位置

5. `int lastIndexOf(Object obj)` 返回obj在当前集合中末次出现的位置

6. `Object remove(int index)` 移除指定index位置的元素，并返回此元素

7. `Object set(int index, Object ele)` 设置指定index位置的元素为ele，相当于是替换

8. `List subList(int fromIndex, int toIndex)` 返回从fromIndex到toIndex位置的子集

## ArrayList的注意事项

1. permits all elements, including null, ArrayList 可以加入null，并且支持加入多个null

2. ArrayList底层是基于数组实现的

3. ArrayList基本等同于Vector，但是ArrayList是线程不安全的；在多线程情况下不建议使用ArrayList

## ArrayList底层结构和源码分析

1. ArrayList中维护了一个Object[]类型的数组elementData。transient Object[] elementData; transient 短暂的、瞬间；表示该属性不会被序列化

2. 创建ArrayList对象时，如果使用无参构造器，则初始化elementData容量为0，第一次添加，则扩容elementData为10，如需要再次扩容，则扩容elementData为1.5倍大小

3. 如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍

## ArrayList和LinkedList的比较

![20230926191930](https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/vscode/20230926191930.png)

一般来说，在程序中，80%-90%是改查，所以大部分情况下使用的是ArrayList

## Set接口和常用方法

### Set接口基本介绍

1. 无序（添加和取出的顺序不一样），虽然无序，但是**固定顺序**没有索引
2. 不允许重复元素，所以最多包含一个null
3. JDK API中Set接口的实现类

### Set接口常用方法

和List接口一样，Set接口是Collection的子接口，所以常用方法和Collection接口一样

### Set接口的遍历方式

和Collection遍历方式一致

1. 使用迭代器
2. 增强for
3. **不能**使用索引的方式

## HashSet的全面说明

1. HashSet实现了Set接口
2. HashSet底层实际上是HashMap
3. 可以存放null值，但是只能有一个null
4. HashSet不保证元素是有序的，取决于hash后，再确定索引的结果。即不保证取出和存入顺序一致
5. 不能有重复元素/对象


示例代码：
```java
public class Main {
    public static void main(String[] args) {
        Emploee yyh = new Emploee("yyh", "1");
        Emploee yyh1 = new Emploee("yyh", "1");
        HashSet a = new HashSet();
        System.out.println(a.add(yyh));//返回true
        System.out.println(a.add(yyh1));//此处会返回false，因为hashcode和equals返回的值都是一样的
    }
}

class Emploee {
    private String name;
    private String age;

    public Emploee(String name, String age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {//重写equals接口
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Emploee emploee = (Emploee) o;
        return Objects.equals(name, emploee.name) && Objects.equals(age, emploee.age);
    }

    @Override
    public int hashCode() {//重写每一个Object类都有的hashCode接口
        return Objects.hash(name, age);
    }
}
```

   
## Map接口和常用方法
1. Map和Collection并列存在。用于保存具有映射关系的数据：Key-Value，即键值对
2. Map中的Key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中
3. Map中的Key不允许重复，原因和HashSet一样，当`put()`的Key重复时，等价于替换
4. Map中的value可以重复
5. Map中的key可以为null，value也可以为null，注意key为null只能有一个，而value为null可以有多个
6. **常用**String类作为Map的key
7. key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value
8. Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的，又因为Node实现了Entry接口，有些书上也说一对k-v就是一个Entry
```java
Map map = new HashMap();
map.put("no1","yyh");
map.put("no2","yyh2");

Set set = map.entrySet();
System.out.println(set.getClass());

//static class Node<K,V> implements Map.Entry<K,V>
//k-v存放于HashMap$Node中，其代码格式为HashMap$Node node = newNode(hash,key,value,null)
//entrySet集合的存在是为了方便程序员进行遍历，该集合存放的元素类型是Entry，一个Entry对象有k和v，即EntrySet<Entry<K,V>>
//entrySet中存放的是Entry，但是其实际上存放的是HashMap$Node。因为HashMap$Node实现了Entry接口，static class Node<K,V> implements Map.Entry<K,V>
//实际上Entry中的k和v都是指向Node的。只是指向！

for(Object obj : set){
    System.out.println(obj.getClass());//输出class java.util.HashMap$Node
}
```

## Map接口和常用方法

1. `put` 添加
2. `remove` 根据键删除映射关系
3. `get` 根据键获取值
4. `size` 获取元素个数
5. `isEmpty` 判断各户是否为0
6. `clear` 清除
7. `containsKey` 查找键是否存在

### Map接口的遍历方法
1. `containsKey` 查找键是否存在
2. `keySet` 获取所有的键
3. `entrySet` 获取所有关系
4. `values` 获取所有的值
   
第一组：先取出所有的key，通过key取出对应的Value
```java
Set keyset = map.keySet();
//(1)增强for循环
for(Object key : keyset){
    System.out.println(key + "-" +map.get(key));
}
//(2)迭代器
Iterator iterator keyset.iterator();
while(iterator.hasNext()){//快捷键itit
    Object next = iterator.next()
}
```
第二组：把所有的values取出来
```java
Collection values = map.values();
//这里可以使用所有的Collections使用的遍历方法
//(1)增强for循环
for(Object value : values){
    System.out.println(value);
}
//(2)迭代器
Iterator iterator = values.iterator();
while(iterator.hasNext()){//快捷键itit
    Object next = iterator.next()
}
```
第三组：通过EntrySet来获取k-v
```java

```