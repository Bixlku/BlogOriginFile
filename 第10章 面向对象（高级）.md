---
title: 第10章 面向对象（高级）
date: 2023-10-10 15:03:00
tags: 韩顺平Java学习
---

# 第10章 面向对象（高级）

## 类变量（静态变量）

1. 类变量由同一个类所有对象共享
2. 类变量在类加载的时候就生成了

### 类变量使用细节

1. 什么时候使用类变量

   当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）

2. 加上`static`称为类变量或静态变量，否则成为实例变量/普通变量/非静态变量

3. 类变量可以通过 `类名.类变量名` 访问或者 `对象名.类变量名` 来直接访问，推荐使用 `类名.类变量名` 访问

   ```java
   Person.id//更好
   Jack.id//不推荐
   ```

## 类方法

### 类方法基本介绍

类方法也叫静态方法，形式如下：

```java
访问修饰符 static 数据返回类型 方法名(){ } 【推荐】
```

调用方式：

```
类名.类方法名/对象名.类方法名
```

### 类方法经典的使用场景

当方法中**不涉及到任何和对象相关的成员**，则可以将方法设计成静态方法，提高开发效率。（例如工具类(`utils类`)、Math类、Arrays类。。。。。）即把方法当作工具使用，无需创建对象。

### 类方法注意事项和细节讨论

1. 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：

   类方法无`this`参数，普通方法隐含`this`参数

2. 类方法可以通过类名调用，也可以通过对象名调用；普通方法和对象有关，需要通过对象名调用

3. 类方法不允许使用和**对象**有关的关键字（fff！！），比如`this`和`super`。普通方法（成员方法）则可以

4. 类方法（静态方法）**只能访问** 静态变量 或 静态方法

5. 普通成员方法，既可以非静态成员，也可以访问静态成员

6. 静态方法只会运行一次

## main方法

1. main方法由虚拟机调用
2. java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public（虚拟机和main不在同一个类）
3. java虚拟机在调用main()方法时不必创建对象，所以该方法必须是static
4. 该方法接收String()类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数
5. `java执行的程序 参数1 参数2 参数3` 命令行运行
6. main方法是静态方法，可以直接调用main方法所在的类的静态方法，但是不能访问该类中的非静态成员（必须在创建一个实例后才能访问）

## 代码块

### 基本介绍

代码块又称为代码块，属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。但其和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。

### 基本语法

```java
static (optional) {
	code
};
```

- 修饰符（static）可选，分为静态代码块和普通代码块（非静态代码块）
- 分号（；）可以省略

### 代码块的好处

- 相当于另一种形式的构造器（对构造器的补充机制），可以做初始化的操作
- 场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性。这样不管用哪个构造器创建任意一个对象，都会调用代码块的内容

### 代码块使用注意事项和细节讨论

1. static代码块也叫做静态代码块，作用是对类进行初始化，而且它随着类的**加载**而执行，并且只会**执行一次**。

   如果是普通代码块，每**创建**一次实例（new）就执行一次。

   如果只是使用类调用静态成员，普通代码块并不会被执行（可以理解为构造器未被调用）。

2. **类什么时候被加载**【重要！必备】【**加载**不等于**创建**，类加载早于对象创建，类加载不一定创建了对象】

   - 创建对象实例时（new）

   - 创建子类对象实例，父类也会被加载

     ```java
     public class CodeBlock {
         public static void main(String[] args) {
             //类被加载的情况举例
             //1.创建对象(new)
             AA aa = new AA();
             //2.创建子类对象那实例，父类也会被加载，而且父类先被加载，子类后被加载
             BB bb = new BB();
             //3.使用类的静态成员时(静态方法、静态成员)
             int c = Cat.n1;  
         }
     }
     
     class AA{
         static {
             System.out.println("AA的静态代码块1被执行");
         }
     }
     
     class BB extends AA{
         static {
             System.out.println("BB的静态代码块1被执行");
         }
     }
     
     class Cat {
         public static int n1 = 999;
         static {
             System.out.println("Cat的静态代码块1被执行");
         }
     }
     ```

   - 使用类的静态成员时（静态属性，静态方法）

     ```java
     public class CodeBlock {
         public static void main(String[] args) {
             //静态代码块在类加载时执行，而且只会被执行一次
             //下列语句只会输出一次"DD的静态方法被代码块1执行"
             //普通代码块在每创建一次类就会执行一次
             //下列两行会输出两次"DD普通代码块被代码块1执行"
             DD dd = new DD();
             DD dd1 = new DD();
             
             //如果只是使用类调用静态成员，普通代码块并不会被执行
             System.out.println(DD.n1);///输出888，静态代码块会执行，普通代码块不会执行
             
         }
     }
     
     class DD{
         public static int n1 = 888;
         static {
             System.out.println("DD的静态方法被代码块1执行");
         }
         {
             System.out.println("DD普通代码块被代码块1执行")
         }
     }
     ```

3. 创建一个对象时，在一个类调用顺序是【重点，难点】：

   1. 调用静态代码块和静态属性初始化（类加载早于对象创建）

      （注意：静态代码和静态属性初始化调用的优先级一样，如果有多个静态代码和多个静态变量初始化，则按他们定义的顺序调用）

   2. 调用普通代码块和普通属性的初始化

      （注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）

   3. 调用构造方法

      ```java
      public class CodeBlock2 {
          public static void main(String[] args) {
              A a = new A();//(1)getN1被调用 (2)A的静态代码块 (3)getN2被调用 (4)A的普通代码块 (5)A无参构造器被调用
          }
      }
      
      class A{
          private static int n1 = getN1();
          private int n2 = getN2();
          {
              System.out.println("A的普通代码块01");//(4)
          }
          static{
              System.out.println("A静态代码块01");//(2)
          }
          
          public static int getN1(){
              System.out.println("getN1被调用");//(1)
              return 100;
          }
          public int getN2(){
              System.out.println("getN2被调用");//(3)
              return 100;
          }
          public A(){
              System.out.println("A无参构造器被调用");//(5)
          }
      }
      ```

   4. 构造方法（构造器）的最前面其实隐含了**super()**和 **调用普通代码块** ，静态相关的代码块，属性初始化，在类加载时就已经执行完毕。

      ```java
      class A{
          public A(){
              //这里有隐藏的执行要求
              //1)super();
              //2)调用本类普通代码块
              System.out.println();
          }
      }
      ```

   5. 创建子类时（有继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：

      1. 父类的静态代码块和静态属性初始化（优先级一致，按定义顺序执行）
      2. 子类的静态代码块和静态属性初始化（优先级一致，按定义顺序执行）
      3. 父类的普通代码块和普通属性初始化（优先级一致，按定义顺序执行）
      4. 父类构造方法
      5. 子类的普通代码块和普通属性初始化（优先级一致，按定义顺序执行）
      6. 子类构造方法

      [代码块综合测试源代码](https://github.com/Bixlku/JavaStudyCode/blob/main/CodeBlock/CodeBlockExam.java)

   6. 静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员

## 单例设计模式

### 什么是设计模式

1. 静态方法和属性的经典应用
2. 设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索

## 什么是单例模式

单例（单个实例）

1. 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法
2. 单例模式有两种方式：1） 饿汉式    2）懒汉式

 ### 饿汉式

即使未使用对象，对象也可能被创建了。饿汉式在加载时就创建了对象，有可能并不使用而造成资源浪费。

1. 构造器私有化 =》防止直接new

2. 类的内部创建对象

3. 向外暴露一个静态的公共方法。 `getInstance`（instance：实例）

4. 代码实现

   ```java
   class SingleTon01(){
       private SingleTon01(){}
       //为了能在静态方法中，返回instance对象，因此将其修饰为static
       private static SingleTon01 instance = new SingleTon01();
       
       public static SingleTon01 getInstance(){
           return instance;
       }
   }
   ```

### 懒汉式

只有使用了getInstance时，才会返回对象，后面再调用时，会返回上次创建的对象，从而保证单例。即使加载类，也不会创建对象

1. 构造器私有化
2. 定义一个static静态属性对象
3. 提供一个public的static方法，返回一个实例

```java
class SingleTon02(){
    private SingleTon01(){}
    
    private static SingleTon02 instance; 
    
    public static SingleTon02 getInstance(){
        if(instance == null) {//如果没创建对象，就进行创建
            instance = new SingleTon02();
        }
        return instance;
    }
}
```

### 饿汉式VS懒汉式

1. 二者最主要的区别在于创建对象的**时机**不同 ：饿汉式在类加载时就创建了对象实例，而懒汉式是在使用时才创建
2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题
3. 饿汉式有浪费资源的可能。
4. Java SE中，java.lang.Runtime就是经典单例模式

## final关键字

### 基本介绍

final可以修饰 类、属性、方法和局部变量

在某些情况下，程序员可能有以下需求，就会用到final：

- 但不希望父类被继承时，可以用final修饰
- 但不希望父类的某个方法被子类覆盖/重写(override)时，可以用final关键字修饰【访问修饰符 final 返回类型 方法名】
- 但不希望类的某个属性的值被修改，可以用final修饰
- 但不希望某个局部变量被修改，可以用final修饰

### final使用注意事项和细节讨论

1. final修饰的属性又叫常量，一般用`XX_XX_XX`来命名

2. final修饰的属性在**定义**时，必须赋初值，并且以后不能再修改，赋初值可以在如下位置之一：

   1. 定义时：如`public final double TAX_RATE  = 0.08;`
   2. 在构造器中
   3. 在代码块中

3. 如果final修饰的属性是**静态**的，则赋初值的位置只能是

   1. 定义时

   2. 在静态代码块

      不能在构造器中赋值

4. final类不能继承，但是可以实例化对象

5. 如果类不是final类，但是含有final方法，则虽然该方法不能重写，但是可以被继承

6. 一般来说，如果一个类已经是final类了，那么其方法就没必要修饰成final了（继承都不行怎么可能重写）

7. final不能修饰构造方法

8. final和static往往搭配使用，效率更高，**不会导致类加载**，底层编译器做了优化处理。

9. 包装类（Integer，Double，Float，Boolean等）都是final，String也是final类

## 抽象类

当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类。

所谓抽象方法就是没有实现的方法，所谓没有实现就是指没有方法体，当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类。一般来说，抽象类会被继承，由其子类来实现抽象方法。

### 抽象类的介绍

1. 用abstract关键字来修饰一个类时，这个类就叫抽象类

   ```java
   访问修饰符 abstract 类名{
   
   }
   ```

2. 用abstract关键字来修饰一个方法时，这个方法就是抽象方法

   ```java
   访问修饰符 abstract 返回类型 方法名(参数列表);//没有方法体
   ```

3. 抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类你

   

### 抽象类的注意事项和细节讨论

1. 抽象类不能被实例化

2. 抽象类不一定要包含abstract方法。也就是说，抽象类可以没有抽象方法

3. 一旦包含了abstract方法，则这个类必须声明为abstract

4. abstract只能修饰 类 和 方法 ，不能修饰属性和其他的

5. 抽象类可以有任意成员【抽象类还是类】，比如：非抽象方法、构造器、静态属性等

6. 抽象方法不能有主体，即下面这种写法是错误的

   ```java
   abstract void a() {}//不能写大括号
   ```

7. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它本身也声明为抽象类

8. 抽象类不能使用private、final、static，因为这些关键字和重写相违背

## 接口（interface）

接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。语法（implements：实施/实现)

```java
interface 接口名{
    //属性
    //方法（1.抽象方法 2.默认实现方法 3.静态方法）
}
class 类名 implements 接口 {
    自己属性;
    自己方法;
    必须实现的接口的全部抽象方法;
}
```


小结：

1. 在JDK7.0之前 接口里的所有方法都没有方法体，即都是抽象方法
2. JDK8.0之后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现
3. 在接口中， 抽象方法可以省略abstract关键字
4. 默认方法需要在方法前加default

### 注意事项和细节

1. 接口不能被实例化

2. 接口中所有的方法都是**public**方法，接口中抽象方法，可以不用abstract修饰

3. 一个普通类实现接口，就必须将该接口的所有方法都实现（IDEA中可以用`alt`+`enter`解决）

4. **抽象类**实现接口，可以不用实现接口的方法

5. 一个类同时可以实现多个接口

6. **接口中的属性**只能是final的，而且是**public static final** 修饰符。比如

   ```java
   在接口中
   int a = 1;//实际上是public static final int a =1;（必须初始化）
   ```

7. 接口中属性的访问形式：接口名.属性名

8. 一个接口不能继承其它的类，但是可以继承多个别的接口。接口和接口之间可以继承

   ```java
   interface A extends B,C{}
   ```

9. 接口的修饰符只能是public或者默认，这点和类的修饰符是一样的

### 实现接口 vs 继承类

接口和继承解决的问题不同

- 接口的价值主要在于：解决代码的复用性和可维护性
- 接口的价值主要在于：设计，设计好各种规范（方法），让其他类去实现这些方法

接口比继承更加灵活，继承需要满足 is-a 的关系，而接口只需满足 like-a 的关系

接口在一定程度上实现代码解耦 [即： 接口规范性+动态绑定]

### 接口的多态性

1. 多态参数

2. 多态数组

3. 多态接口传递

   ```java
   public class InterfacePoly {
       public static void main(String[] args) {
           IF if01 = new IH();
           //如果IG 继承了 IH接口，而Teacher类实现了 IG接口
           //那么，实际上就相当于Teacher类也实现了 IH接口
           //这就是所谓的接口多态传递现象
           IG ig01 = new IH();
       }
   }
   
   interface IG{}
   interface IF extends IG{}
   class IH implements IF{}
   ```

### 类定义的进一步完善

<img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220225110910353.png" alt="image-20220225110910353" style="zoom: 33%;" />

## 内部类

一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类（inner class），嵌套其他类的类称为外部类（outer class）。是我们类的第五大成员[属性、方法、构造器、代码块、内部类]，内部类的最大特点是可以直接访问私有属性，并且可以体现类与类之间的包含关系。

### 基本语法

```java
class Outer{//外部类
    class inner{//内部类
    }
}
class Other{//外部其他类 
}
```

### 内部类的分类

定义在外部类局部位置上：

- 局部内部类（有类名）
- **匿名内部类**（没有内部类，重点！）

定义在外部类的成员位置上：

- 成员内部类（没有static修饰）
- 静态内部类（使用static修饰）

### 局部内部类

局部内部类是定义在外部类的局部位置，比如方法中，并且有类名

1. 可以直接访问外部类的所有成员，包括私有的
2. 不能添加访问修饰符，但是可以使用`final`修饰。因为它的地位就是一个局部变量，局部变量不能使用修饰符
3. **作用域**：仅仅在定义它的方法或代码块中
4. 局部内部类---访问--->外部类的成员 【访问方式：直接访问】
5. 外部类---访问--->局部内部类的成员 【访问方式：创建对象，再访问（注意：必须在作用域内）】
6. 外部其他类---**不能访问**--->局部内部类（因为局部内部类地位是一个**局部变量**）
7. 如果外部类和局部内部类的成员重名时，默认遵循**就近原则**，如果想访问外部类的成员，则可以使用`外部类名.this.成员`去访问

```java
public class LocalInnerClass {
    public static void main(String[] args) {
    }
}

class Outer02 {
    private int n1 = 100;
    private void m2(){};
    public void m1() {//方法
        class Inner02 {//局部内部类，本质还是一个类
            //可以直接访问外部类的所有成员，包含私有的
            int n1 = 100;
            public void f1() {
                //局部内部类可以直接访问外部类的成员，例如n1和m2
                //如果外部类和局部内部类的成员重名时，默认遵循就近原则
                //如果想访问外部类的成员，则可以使用`外部类名.this.成员`去访问
                //Outer02.this 表示的本质就是外部类的对象，即哪个对象调用了m1，Outer02.this就是哪个对象
                System.out.println("n1=" + n1 + "外部类的n1=" +Outer02.this.n1);
                m2();
            }
        }
        //需要创建Outer类的对象再进行访问
        Outer02 outer02 = new Outer02();
        System.out.println(outer02.n1);
    }
}
```

### 匿名内部类(重点)

（1）本质是类 （2）内部类 （3）该类没有名字 （4）同时还是一个对象

匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名的内部类

1. 匿名内部类的基本语法

   ```java
   new 类或接口(参数列表){
       类体
   };
   ```

2. 匿名内部类的语法比较奇特，请注意，因为匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征，对前面代码的分析可以看出这个特点，因此可以调用匿名内部类的的方法。

3. 可以直接访问外部类的所有成员，包含私有的

4. 不能添加访问修饰符，因为他的地位就是一个局部变量

5. 作用域：仅仅在定义它的方法或者代码块中

6. 匿名内部类---访问---->外部类成员[访问方式：直接访问]

7. 外部其他类---不能访问---->匿名内部类（因为 匿名内部类地位是一个局部变量）

8. 如果外部类和内部类的成员重名时，内部类访问的话，默认遵循**就近原则**，如果想访问外部类的成员，则可以使用（`外部类名.this.成员`）去访问

9. 匿名内部类包含了继承、多态、动态绑定、内部类的知识

#### 匿名内部类实践

当作实参传递，简洁高效

[匿名内部类示例代码](https://github.com/Bixlku/JavaStudyCode/tree/main/AnonymousInnerClass)

### 成员内部类

成员内部类是定义在外部类的成员位置，并且没有static修饰

1. 可以**直接访问**外部类的所有成员，包括私有的

   ```java
   class Outer01{
       private int n1 = 100;
       
       class Inner01{
           public void cry(){
               System.out.println("调用cry方法");
           }
       }
   }
   ```

2. 可以添加任意访问修饰符(public、private、默认、protected)，因为它的定义也是一个成员

3. 作用域和外部类的其他成员一样，为**整个类体**。在外部类的成员方法中创建成员内部类对象，再调用方法

4. 成员内部类---访问---->外部类成员[访问方式：直接访问]

5. 外部类---访问---->内部类（访问方式：创建对象，再访问）

6. 外部其他类---访问---->成员内部类

   ```java
   public class InnerClass {
       Outer08 outer = new Outer08();
       //第一种方式，相当于把new Inner()当作是outer的成员，只是语法，不需要太仔细想
       Outer08.Inner inner1 = outer.new Inner();//第一种外部其他类访问成员内部类的方方式
       //第二种方式，在外部类中，编写一个方法，可以返回Inner对象
       Outer08.Inner inner2 = outer.getInnerInstance();//第二种外部其他类访问成员内部类的方方式
   }
   
   class Outer08{//外部类
       private String name;
       private int n1 = 99;
   
       public class Inner{//内部类
           private int in = 2;
           public void say(){
               System.out.println("调用Inner的say方法");
           }
       }
       
       public Inner getInnerInstance(){
           return new Inner();
       }
   }
   ```

7. 如果外部类和内部类的成员重名时，内部类访问的话，默认遵循**就近原则**，如果想访问外部类的成员，则可以使用（`外部类名.this.成员`）去访问

### 静态内部类

静态内部类是定义在外部类的成员位置，并且有static修饰

1. 可以直接访问外部类的所有静态成员，包括私有的，但不能直接访问**非静态成员**

2. 可以添加任意访问修饰符，因为它的地位就是一个成员

3. 作用域：同其他的成员，为整个整体

4. 静态内部类---访问---->外部类成员[访问方式：直接访问]

5. 外部类---访问---->静态内部类（访问方式：创建对象，再访问）

6. 外部其他类---访问---->静态内部类（因为 匿名内部类地位是一个局部变量）

   ```java
   public class StaticInnerClass {
       public static void main(String[] args) {
           Outer01 outer = new Outer01();
           //方式1. 因为静态内部类，是可以通过类名直接访问（前提是满足访问权限）
           Outer01.Inner01 inner01 = new Outer01.Inner01();
           inner01.say();
           //方式2. 编写一个方法，可以返回静态内部类的实例
           Outer01.Inner01 inner01Instance = outer.getInner01Instance();//使用非静态方法
           Outer01.Inner01 inner01Instance_ = Outer01.getInner01Instance_();//使用静态方法（如果不想创建一个外部对象可以直接这样用类名）
       }
   }
   
   class Outer01{
       private int n1 = 9;
   
       static class Inner01{
           public void say(){
               System.out.println("调用静态内部类的say方法");
           }
       }
       public Inner01 getInner01Instance(){
           return new Inner01();
       }
       static public Inner01 getInner01Instance_(){
           return new Inner01();
       }
   }
   ```

7. 如果外部类和内部类的成员重名时，内部类访问的话，默认遵循**就近原则**，如果想访问外部类的成员，则可以使用（`外部类名.成员`）去访问