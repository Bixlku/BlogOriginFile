---
title: 第11章 枚举和注解
date: 2023-10-10 15:02:00
tags: 韩顺平Java学习
---

# 第11章 枚举和注解

## 枚举(enumeration)

### 自定义类实现枚举 

1. 构造器私有化
2. 本类内部创建一组对象
3. 对外暴露对象（通过为对象添加访问修饰符）
4. 可以提供get方法，但是不提供set方法

```java
public class Enumeration01 {
    public static void main(String[] args) {
        System.out.println(Season.AUTUMN.toString());
    }
}

class Season{
    private String name;
    private String desc;

    final public static Season SPRING = new Season("春天","温暖");
    final public static Season SUMMER = new Season("夏天","炎热");
    final public static Season AUTUMN = new Season("秋天","萧瑟");
    final public static Season WINTER = new Season("冬天","寒冷");

    private Season(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    private String getName() {
        return name;
    }

    private String getDesc() {
        return desc;
    }
}
```

### enum关键字实现枚举

1. 使用关键字enum替代class
2. SPRING("春天","温暖") 解读 常量名(实参列表)
3.  如果使用enum来实现枚举，枚举对象应当写在前面

```java
public class Enumeration02 {
    public static void main(String[] args) {
        System.out.println(Season.AUTUMN.toString());
    }
}

enum Season1 {
    SPRING("春天","温暖"),
    SUMMER("夏天","炎热"),
    AUTUMN("秋天","萧瑟"),
    WINTER("冬天","寒冷");
    
    private String name;
    private String desc;
    
    private Season1(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    private String getName() {
        return name;
    }

    private String getDesc() {
        return desc;
    }
}
```

#### enum关键字实现枚举的注意事项

1. 当使用enum关键字开发一个枚举类时，默认会**继承Enum类**（使用javap验证）
2. `final public static Season SPRING = new Season("春天","温暖");`   简化为  `SPRING("春天","温暖"),`这里必须理解其调用的是哪个构造器
3. 如果使用无参构造器 创建 枚举对象，则实参列表的小括号可以省略

#### enum常用方法说明

| 方法名            | 详细描述                                                     |
| ----------------- | ------------------------------------------------------------ |
| valueOf           | 传递枚举类型的Class对象和枚举常量名称给**静态方法**valueOf，会得到与参数匹配的枚举常量。将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常。 |
| toString          | 得到当前枚举常量的名称。你可以通过重写这个方法来使得到的结果更易读 |
| equals            | 在枚举类型中可以直接使用`==`来比较两个枚举常量是否相等。Enum提供的这个`equals0`方法，也是直接使用`==`实现的。它的存在是为了在Set、List和Map中使用。注意，equals()是不可变的。 |
| hashCode          | Enum实现了hashCode()来和equals0保持一致。它也是不可变的。    |
| getDeclaringClass | 得到枚举常量所属枚举类型的Class对象。可以用它来判断两个枚举常量是否属于同一个枚举类型。 |
| name              | 得到当前枚举常量的名称。建议优先使用toString()。             |
| ordinal           | 得到当前枚举常量的次序。                                     |
| compareTo         | 枚举类型实现了Comparable接口，这样可以比较两个枚举常量，比较的是编号（按照声明的顺序排列） |
| clone             | 枚举类型不能被Clone.。为了防止子类实现克隆方法，Enum实现了一个仅抛出CloneNotSupportedException异常的不变Clone()。 |
| values            | 含有定义的所有枚举对象（是个数组）                           |

## 注解(annotation)

注解也被称为元数据，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息。和注释一样，注解不影响程序逻辑，但注解可以被编译或者运行，相当于前在代码中的补充信息。

1. @Override： 限定某个方法，是重写父类方法，该注解只能用于方法
2. @Deprecated： 用于表示某个程序元素（类，方法等）已过时
   1. 过时不代表不能使用，只是不推荐使用
   2. 可以修饰方法、类、字段、包、参数 等等
   3. @Deprecated可以用于版本升级，过渡使用
3. @SuppressWarnings： 抑制编译器警告
   1. 在大括号中可以抑制不希望看到的警告信息，例如 `@SuppressWarnings({"all"})`，警告类型很多，具体的话查文档
   2. @SuppressWarnings 作用范围和放置位置有关，可以放在类上，也可以放在方法上

### 元注解

元注解本身作用不大，在看源代码的时候看得懂就行